import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject } from '@angular/core';
import { Subject, merge } from 'rxjs';
import { map, auditTime, takeUntil } from 'rxjs/operators';
import set from 'lodash.set';
import * as i1 from '@angular/router';

const BIND_QUERY_PARAMS_OPTIONS = new InjectionToken('BIND_QUERY_PARAMS_OPTIONS', {
    providedIn: 'root',
    factory() {
        return {
            windowRef: window,
        };
    },
});

function isEmptyValue(def, value) {
    switch (def.type) {
        case 'array':
            return !value || !value.length;
        case 'object':
            return !value || !Object.keys(value).length;
        case 'string':
            return !value || value === '';
        default:
            return false;
    }
}
function parse(value, type) {
    switch (type) {
        case 'string':
            return value;
        case 'boolean':
            return value === 'false' ? false : !!value;
        case 'array':
            return value === null || value === void 0 ? void 0 : value.split(',');
        case 'number':
            return +value;
        case 'object':
            return JSON.parse(value);
        default:
            return value;
    }
}
function get(obj, path) {
    let current = obj;
    path.split('.').forEach((p) => (current = current[p]));
    return current;
}
function resolveParams(params) {
    const toArray = coerceArray(params);
    const result = {};
    toArray.forEach(({ def, value }) => {
        let defValue;
        if (def.removeEmptyValue) {
            defValue = isEmptyValue(def, value) ? null : def.serialize(value);
        }
        else {
            defValue = def.serialize(value);
        }
        result[def.queryKey] = defValue;
    });
    return result;
}
function coerceArray(value) {
    return Array.isArray(value) ? value : [value];
}
function defsToParams(defs, group) {
    return defs.map((def) => {
        return {
            queryKey: def.queryKey,
            value: group.get(def.path).value,
        };
    });
}

class QueryParamDef {
    constructor(config) {
        this.config = config;
    }
    get queryKey() {
        return this.config.queryKey;
    }
    get path() {
        return this.config.path || this.queryKey;
    }
    get type() {
        return this.config.type || 'string';
    }
    get parser() {
        return this.config.parser;
    }
    get syncInitialControlValue() {
        return this.config.syncInitialControlValue;
    }
    get syncInitialQueryParamValue() {
        var _a;
        return (_a = this.config.syncInitialQueryParamValue) !== null && _a !== void 0 ? _a : true;
    }
    get serializer() {
        return this.config.serializer;
    }
    get removeEmptyValue() {
        return this.config.removeEmptyValue === undefined ? true : this.config.removeEmptyValue;
    }
    serialize(controlValue) {
        if (this.serializer) {
            return this.serializer(controlValue);
        }
        if (controlValue === null || controlValue === undefined || controlValue === '') {
            return null;
        }
        const serializedValue = controlValue.toString();
        return serializedValue === '[object Object]' ? JSON.stringify(controlValue) : serializedValue;
    }
    parse(queryParamValue) {
        if (this.parser) {
            return this.parser(queryParamValue);
        }
        return parse(queryParamValue, this.type);
    }
}

class BindQueryParamsManager {
    constructor(router, defs, options, createOptions) {
        this.router = router;
        this.options = options;
        this.createOptions = createOptions;
        this.$destroy = new Subject();
        this.defsSynced = {};
        this.defs = coerceArray(defs).map((def) => new QueryParamDef(def));
    }
    connect(group) {
        this.group = group;
        this.onInit();
        return this;
    }
    onInit() {
        this.handleInitialURLSync();
        this.updateControl(this.defs, { emitEvent: true }, (def) => { var _a, _b; return !!((_a = def.syncInitialQueryParamValue) !== null && _a !== void 0 ? _a : (_b = this.createOptions) === null || _b === void 0 ? void 0 : _b.syncInitialQueryParamValue); });
        const controls = this.defs.map((def) => {
            return this.group.get(def.path).valueChanges.pipe(map((value) => ({
                def,
                value,
            })));
        });
        // Could be a several changes in the same tick,
        // for example when we use reset() or patchValue.
        // We need to aggregate the changes and apply them once
        // because the router navigates in micro task
        let buffer = [];
        merge(...controls)
            .pipe(map((result) => buffer.push(result)), auditTime(0), takeUntil(this.$destroy))
            .subscribe(() => {
            this.updateQueryParams(resolveParams(buffer));
            buffer = [];
        });
    }
    destroy() {
        this.$destroy.next();
    }
    getDef(queryKey) {
        return this.defs.find((def) => def.queryKey === queryKey);
    }
    parse(queryParams) {
        const result = {};
        for (const [key, value] of Object.entries(queryParams)) {
            const def = this.getDef(key);
            if (def) {
                result[key] = def.parse(value);
            }
        }
        return result;
    }
    syncAllDefs(options = { emitEvent: true }) {
        const allKeys = this.defs.map((def) => def.queryKey);
        this.syncDefs(allKeys, options);
    }
    syncDefs(queryKeys, options = { emitEvent: true }) {
        const defs = [];
        coerceArray(queryKeys).forEach((key) => {
            if (!this.defsSynced[key]) {
                this.defsSynced[key] = true;
                const def = this.getDef(key);
                if (def) {
                    defs.push(def);
                }
            }
        });
        if (defs.length) {
            this.updateControl(defs, options);
        }
    }
    paramExists(queryKey) {
        return this.search.has(queryKey);
    }
    someParamExists() {
        return this.defs.some((def) => {
            return this.search.has(def.queryKey);
        });
    }
    get search() {
        return new URLSearchParams(this.options.windowRef.location.search);
    }
    handleInitialURLSync() {
        var _a, _b;
        const initialSyncDefs = [];
        for (const def of this.defs) {
            const syncInitialControlValue = (_a = def.syncInitialControlValue) !== null && _a !== void 0 ? _a : (_b = this.createOptions) === null || _b === void 0 ? void 0 : _b.syncInitialControlValue;
            if (syncInitialControlValue && !this.paramExists(def.queryKey)) {
                initialSyncDefs.push({ def, value: get(this.group.value, def.path) });
            }
        }
        if (initialSyncDefs.length) {
            this.updateQueryParams(Object.assign(Object.assign({}, Object.fromEntries(this.search)), resolveParams(initialSyncDefs)));
        }
    }
    updateQueryParams(queryParams) {
        this.router.navigate([], {
            queryParams,
            queryParamsHandling: 'merge',
            replaceUrl: true,
        });
    }
    updateControl(defs, options, updatePredicate = (_) => true) {
        const queryParams = new URLSearchParams(this.options.windowRef.location.search);
        let value = {};
        for (const def of defs) {
            if (updatePredicate(def)) {
                const { queryKey } = def;
                const queryParamValue = queryParams.get(queryKey);
                if (!queryParamValue)
                    continue;
                set(value, def.path.split('.'), def.parse(queryParamValue));
            }
        }
        if (Object.keys(value).length) {
            this.group.patchValue(value, options);
        }
    }
}

class BindQueryParamsFactory {
    constructor(router, options) {
        this.router = router;
        this.options = options;
    }
    create(defs, createOptions) {
        return new BindQueryParamsManager(this.router, defs, this.options, createOptions);
    }
}
BindQueryParamsFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: BindQueryParamsFactory, deps: [{ token: i1.Router }, { token: BIND_QUERY_PARAMS_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
BindQueryParamsFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: BindQueryParamsFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: BindQueryParamsFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () {
        return [{ type: i1.Router }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [BIND_QUERY_PARAMS_OPTIONS]
                    }] }];
    } });

/**
 * Generated bundle index. Do not edit.
 */

export { BIND_QUERY_PARAMS_OPTIONS, BindQueryParamsFactory, BindQueryParamsManager };
//# sourceMappingURL=ngneat-bind-query-params.mjs.map
